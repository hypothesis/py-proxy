# Tell nginx not to daemonize (background) itself: http://nginx.org/en/docs/ngx_core_module.html#daemon
daemon off;

# Change the location of the file that stores nginx's process ID: http://nginx.org/en/docs/ngx_core_module.html#pid
# TODO: Why do we change this?
pid /var/lib/hypothesis/nginx.pid;

# Log errors to stderr: http://nginx.org/en/docs/ngx_core_module.html#error_log
error_log /dev/stderr;

# How many files a worker can open at once: http://nginx.org/en/docs/ngx_core_module.html#worker_rlimit_nofile
# This has to be greater than or equal to worker_connections below.
# TODO: Why have we chosen this number?
worker_rlimit_nofile 7192;

events {
    # How many connections a worker can open at once: http://nginx.org/en/docs/ngx_core_module.html#worker_connections
    # TODO: Why have we chosen this number?
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;

    # Configure the DNS that nginx uses to connect to the servers it's proxying.
    # http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver
    # TODO: Do we need to change this? Why have we chosen this value?
    resolver 8.8.8.8 ipv6=off;

    # Log accesses to stdout: http://nginx.org/en/docs/http/ngx_http_log_module.html#access_log
    access_log /dev/stdout;

    # Set $original_scheme to the protocol that the browser used to connect to Via
    # ("http" or "https"), based on the X-Forwarded-Proto header. We'll need
    # this variable later.
    #
    # $original_scheme is needed because AWS's load balancer connects to the
    # app server using HTTP so nginx's default $scheme is always "http" in
    # production.
    #
    # If there's no X-Forwarded-Proto header $original_scheme falls back to
    # $scheme ("http").
    #
    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto
    # http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_
    # http://nginx.org/en/docs/http/ngx_http_map_module.html#map
    # http://nginx.org/en/docs/http/ngx_http_core_module.html#var_scheme
    map $http_x_forwarded_proto $original_scheme {
        "" $scheme;
        default $http_x_forwarded_proto;
    }

    include via/app_upstream.conf;

    server {
        include /var/lib/hypothesis/nginx_envsubst.conf;

        # Route requests on port 9083 go to this `server { ... }` block.
        listen 9083;

        # By default nginx merges two or more consecutive slashes in a URL into
        # one. Turn this off since our URLs deliberately contain consecutive
        # slashes in the URL-to-be-proxied ("https://example.com").
        # http://nginx.org/en/docs/http/ngx_http_core_module.html#merge_slashes
        merge_slashes off;

        location ~ /proxy/static/ {
            # Intercept 3xx, 4xx and 5xx responses from the servers we're
            # proxying and process them through the error_page directives
            # below: http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors
            proxy_intercept_errors on;

            # Don't pass 3xx responses from the servers we're proxying back to
            # the browser. Instead process them through the @handle_redirect
            # location below.
            # http://nginx.org/en/docs/http/ngx_http_core_module.html#error_page
            error_page 301 302 307 = @handle_redirect;

            # Don't pass 4xx or 5xx responses from the servers we're proxying
            # back to the browser. Instead process them through the @proxy_*
            # locations defined below.
            #
            # If users are proxying a third-party server that is returning
            # error responses we don't want Via 3 to return those same 4xx or
            # 5xx status codes to the browser because this would mess up our
            # monitoring and alerting. For example it might trigger an alarm
            # that Via 3 is unhealthy because it's sending too many error
            # responses.
            # http://nginx.org/en/docs/http/ngx_http_core_module.html#error_page
            error_page 404 410 = @proxy_not_found;
            error_page 420 429 = @proxy_too_many_requests;
            error_page 400 401 402 403 405 406 407 408 409 411 412 413 414 415 416 417 418 422 423 424 425 426 428 431 444 449 450 451 = @proxy_client_error;
            error_page 500 501 502 503 504 505 506 507 508 509 510 511 598 599 = @proxy_upstream_error;

            include via/direct_proxy.conf;

            # Cache for one day, but allow serving from cache while revalidating for a week.
            # https://web.dev/stale-while-revalidate/
            proxy_hide_header "Cache-Control";
            add_header "Cache-Control" "public, max-age=86400, stale-while-revalidate=604800";

            # Add an X-Via header for debugging.
            add_header "X-Via" "static-proxy, direct";

            # Tell Google not to index or follow links on proxied pages.
            # https://developers.google.com/search/reference/robots_meta_tag
            add_header "X-Robots-Tag" "noindex, nofollow";
        }

        location @handle_redirect {
            include via/direct_proxy.conf;

            # Don't cache redirect responses because they can be temporary
            # redirects to PDF URLs that expire over time (the Canvas Files API
            # does this, for example).
            proxy_hide_header "Cache-Control";
            add_header "Cache-Control" "no-cache, no-store, must-revalidate";

            # Add an X-Via header for debugging.
            add_header "X-Via" "static-proxy, redirect";
        }

        location @proxy_not_found {
            # http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return
            return 404;
        }

        location @proxy_too_many_requests {
            # http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return
            return 429;
        }

        location @proxy_client_error {
            # http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return
            return 400;
        }

        location @proxy_upstream_error {
            # http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return
            return 409;
        }

        location / {
            # Proxy to the Gunicorn/Pyramid app.
            # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass
            proxy_pass http://web;

            # Use HTTP 1.1 for proxying to the Gunicorn/Pyramid app.
            # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_http_version
            proxy_http_version 1.1;

            proxy_connect_timeout 10s;
            proxy_send_timeout 10s;
            # This is how long we will wait for a response from the service
            # This has to be longer than the time we wait for websites to
            # allow us to handle timeouts inside the app
            proxy_read_timeout 20s;

            # Send the full HTTP Host header (including the port) through to
            # the Gunicorn/Pyramid app.
            # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header
            # http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_
            # TODO: Why do we need to do this?
            proxy_set_header Host $http_host;

            proxy_set_header X-Forwarded-Server $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_set_header X-Request-Start "t=${msec}";

            # Add an X-Via header for debugging.
            add_header "X-Via" "compute";

            # Tell Google not to index or follow links on proxied pages.
            # https://developers.google.com/search/reference/robots_meta_tag
            add_header "X-Robots-Tag" "noindex, nofollow";
        }
    }
}
